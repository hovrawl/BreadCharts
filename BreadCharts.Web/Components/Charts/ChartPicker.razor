@using System.Timers;
@using BreadCharts.Core.Models
@using BreadCharts.Core.Services
@using BreadCharts.Web.Data
@using Microsoft.AspNetCore.Identity
@inject ISpotifyClientService SpotifyClientService
@inject UserManager<ApplicationUser> UserManager
@inject IHttpContextAccessor HttpContextAccessor
@inject NavigationManager NavigationManager

<FluentStack Orientation="Orientation.Vertical" Class="overflow-y">
    <FluentSearch @ref=searchTest
                  @bind-Value="SearchValue"
                  @bind-Value:after="HandleClear"
                  @oninput="@(e => SearchValue = e.Value?.ToString())"
                  Placeholder="Search for songs" />
    <br />
    <FluentStack Orientation="Orientation.Horizontal" Class="chart-picker overflow-y">
        <FluentListbox
            Class="overflow-y"
            aria-label="search results"
            Items=@searchResults
            TOption="ChartOption"
            @bind-SelectedOption="SelectedChartOption"
            OptionValue="@(option => option.Id)"
        >
            <OptionTemplate>
                <FluentStack Orientation="Orientation.Horizontal">
                    @GetIconForChartOptionType(context.Type)
                    <span>
                        @context.Name
                    </span>
                    @if (context.Type != ChartOptionType.Track)
                    {
                        <FluentSpacer></FluentSpacer>
                        <FluentIcon Icon="Icons.Regular.Size20.ChevronRight" Slot="end"/>
                    }
                </FluentStack>
       
            </OptionTemplate>
        </FluentListbox>
        @if (SelectedChartOption != null)
        {
            <ChartItemInfo ChartOption="@SelectedChartOption" />

        }
    </FluentStack>
</FluentStack>



@code {
    private Timer? timer = null;

    private FluentSearch? searchTest;

    private string? searchValue = string.Empty;

    private string? SearchValue
    {
        get => searchValue;
        set
        {
            if (value != searchValue)
            {
                searchValue = value;
                DisposeTimer();
                //ShowMessageBar the debounce time in ms to the timer below
                timer = new Timer(600);
                timer.Elapsed += TimerElapsed_TickAsync;
                timer.Enabled = true;
                timer.Start();
            }
        }
    }

    public ChartOption? SelectedChartOption { get; set; }

    private List<ChartOption> searchResults = defaultResults();

    private static ChartOption defaultResultsText = new ()
    {
        Id = "no-options",
        Name = "No Results"
    };

    protected override async Task OnInitializedAsync()
    {
        
    }


    private static List<ChartOption> defaultResults()
    {
        return new() { defaultResultsText };
    }

    private async void TimerElapsed_TickAsync(object? sender, EventArgs e)
    {
        DisposeTimer();
        await InvokeAsync(OnSearch);
    }

    private void DisposeTimer()
    {
        if (timer != null)
        {
            timer.Enabled = false;
            timer.Elapsed -= TimerElapsed_TickAsync;
            timer.Dispose();
            timer = null;
        }
    }

    private async Task OnSearch()
    {
        if (!string.IsNullOrWhiteSpace(SearchValue))
        {
            string searchTerm = SearchValue.ToLower();

            //You can also call an API here if the list is not local
            var context = HttpContextAccessor.HttpContext;
            var user = context != null ? await UserManager.GetUserAsync(context.User) : null;
            var access = context?.User?.FindFirst("urn:spotify:access_token")?.Value;
            var refresh = context?.User?.FindFirst("urn:spotify:refresh_token")?.Value;
            List<ChartOption> results;
            if (user is not null && !string.IsNullOrEmpty(access))
            {
                try
                {
                    results = await SpotifyClientService.Search(user.Id, access!, refresh, searchTerm);
                }
                catch
                {
                    // Token invalid/refresh failed, redirect to welcome for re-auth
                    NavigationManager.NavigateTo("/welcome", replace: true);
                    results = new List<ChartOption>();
                }
            }
            else
            {
                results = new List<ChartOption>();
            }
            searchResults = results
                .OrderBy(o => SortKey(o.Name, searchTerm))
                .ThenBy(o => o.Name, StringComparer.CurrentCultureIgnoreCase)
                .ToList();

            if (!searchResults.Any())
            {
                searchResults = defaultResults();
            }
            StateHasChanged();
        }
        else
        {
            searchResults = defaultResults();
            StateHasChanged();
        }
    }

    private void HandleClear()
    {
        if (string.IsNullOrWhiteSpace(SearchValue))
            return;

        DisposeTimer();
        searchResults = defaultResults();
        SearchValue = string.Empty;
        StateHasChanged();
    }

    private static (int priority, int position, int lengthDelta) SortKey(string? name, string term)
    {
        if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(term))
            return (int.MaxValue, int.MaxValue, int.MaxValue);

        // 0 = exact, 1 = startswith, 2 = contains, 3 = no match
        if (string.Equals(name, term, StringComparison.OrdinalIgnoreCase))
            return (0, 0, 0);

        if (name.StartsWith(term, StringComparison.OrdinalIgnoreCase))
            return (1, 0, Math.Abs(name.Length - term.Length));

        var idx = name.IndexOf(term, StringComparison.OrdinalIgnoreCase);
        if (idx >= 0)
            return (2, idx, Math.Abs(name.Length - term.Length));

        return (3, int.MaxValue, Math.Abs(name.Length - term.Length));
    }

    private RenderFragment GetIconForChartOptionType(ChartOptionType chartOptionType) => builder =>
    {
        try
        {
            Type iconType = chartOptionType switch
            {
                ChartOptionType.Artist => typeof(Icons.Regular.Size20.Person),
                ChartOptionType.Album => typeof(Icons.Regular.Size20.Album),
                ChartOptionType.Track => typeof(Icons.Regular.Size20.SoundWaveCircle),
                ChartOptionType.Playlist => typeof(Icons.Regular.Size20.ListBar),
                _ => typeof(Icons.Regular.Size20.Question)
            };

            var fluentIconType = typeof(FluentIcon<>).MakeGenericType(iconType);
            builder.OpenComponent(0, fluentIconType);
            builder.AddAttribute(1, "Slot", "start");
            builder.CloseComponent();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error rendering icon: {ex.Message}");
        }


    };
}

<style>
    .chart-picker > div{
        max-height: 100%;
    }
</style>